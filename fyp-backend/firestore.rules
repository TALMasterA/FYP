rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // EXISTING RULE: User Data Subcollections
    // Users can only access their own subcollections
    // This rule matches subcollections like /users/{userId}/profile/settings
    // but NOT the main document /users/{userId} itself
    // ============================================
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================
    // Block List: /users/{userId}/blocked_users/{blockedId}
    // Only the owner can read/write their block list.
    // Other users can read IF they are the blocked party (to check if they're blocked).
    // ============================================
    match /users/{userId}/blocked_users/{blockedId} {
      // Owner can fully manage their block list
      allow read, write: if request.auth != null && request.auth.uid == userId;
      // Blocked user can check if they are blocked (needed for UI block-status check)
      allow read: if request.auth != null && request.auth.uid == blockedId;
    }

    // ============================================
    // Main User Document: /users/{userId}
    // Two access patterns:
    // 1. Owner can read/write their own document
    // 2. Cross-user writes for unread message counters only
    // ============================================
    match /users/{userId} {
      // Allow owner to read/write their own document
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Allow cross-user writes for unread counters only
      // This covers both .update() and .set() with merge
      allow write: if request.auth != null
        && request.auth.uid != userId
        && onlyUpdatingUnreadCounters();
    }

    // Helper function to check if only unread counter fields are being modified
    function onlyUpdatingUnreadCounters() {
      // The app uses update() with DOT-NOTATION (e.g., "unreadPerFriend.{friendId}")
      // to avoid overwriting sibling entries in nested maps.
      // Falls back to set() with merge for document creation.
      //
      // When the document doesn't exist yet (resource == null):
      // - For new documents, check that we're only creating the allowed fields
      //
      // When the document exists (resource != null):
      // - Check that only the allowed fields are being modified
      //
      // Note: When using dot notation like "unreadPerFriend.{friendId}", Firestore treats
      // the entire map field 'unreadPerFriend' as changed, not individual subfields.

      return resource == null
        ? request.resource.data.keys().hasOnly(['totalUnreadMessages', 'unreadPerFriend'])
        : request.resource.data.diff(resource.data).affectedKeys().hasOnly(['totalUnreadMessages', 'unreadPerFriend']);
    }

    // ============================================
    // Friends Feature - Shared Inbox
    // Allow authenticated users to CREATE (send) shared items into another user's inbox.
    // The sender's fromUserId must match their auth UID.
    // The recipient (owner) can read, update (accept/dismiss) via the owner rule above.
    // ============================================
    match /users/{userId}/shared_inbox/{itemId} {
      // Any authenticated user can send (create) a shared item to another user's inbox.
      // fromUserId in the document must match the authenticated sender.
      allow create: if request.auth != null
        && request.resource.data.fromUserId == request.auth.uid;

      // Allow creating the content subcollection (e.g. for learning sheets)
      match /content/{docId} {
        allow create: if request.auth != null
          && request.resource.data.fromUserId == request.auth.uid;
      }
    }

    // ============================================
    // NEW: Friends Feature - Public Profiles
    // Allow authenticated users to read public profiles of any user
    // ============================================
    match /users/{userId}/profile/public {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================
    // NEW: Friends Feature - Friends List
    // Allow users to read their own friends list
    // Also allow batch writes when accepting friend requests (both users get updated)
    // ============================================
    match /users/{userId}/friends/{friendId} {
      // Users can read their own friends
      allow read: if request.auth != null && request.auth.uid == userId;

      // Users can write to their own friends list
      allow write: if request.auth != null && request.auth.uid == userId;

      // Special case: Allow writing to friend's list when accepting friend request
      // This happens in a batch transaction where both users' friends lists are updated
      allow write: if request.auth != null && request.auth.uid == friendId;
    }

    // ============================================
    // NEW: Feedback Collection (For feedback feature)
    // Authenticated users can submit feedback
    // ============================================
    match /feedback/{feedbackId} {
      // Allow authenticated users to create feedback
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.message is string
                    && request.resource.data.message.size() > 0
                    && request.resource.data.message.size() <= 5000;

      // Feedback is write-only for users (only admins should read - not implemented yet)
      allow read, update, delete: if false;
    }

    // ============================================
    // NEW: Friends Feature - Username Registry
    // ============================================
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
        && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null 
        && resource.data.userId == request.auth.uid;
    }

    // ============================================
    // NEW: Friends Feature - User Search Index
    // ============================================
    match /user_search/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // ============================================
    // NEW: Friends Feature - Friend Requests
    // ============================================
    match /friend_requests/{requestId} {
      // Read if sender or receiver
      allow read: if request.auth != null && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );

      // Create if authenticated and sender
      allow create: if request.auth != null 
        && request.resource.data.fromUserId == request.auth.uid
        && request.resource.data.status == "PENDING";

      // Update: only allowed for sender renaming their username on pending requests.
      // Accept/reject/cancel all now DELETE the doc instead of updating status.
      allow update: if request.auth != null &&
        resource.data.fromUserId == request.auth.uid &&
        resource.data.status == "PENDING" &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(["fromUsername"]);

      // Allow sender or receiver to delete ANY of their requests (any status).
      // This covers:
      //   - Recipient accepting (deletes the PENDING request atomically with friend creation)
      //   - Cleanup of stale docs when unfriending (so re-add always works)
      //   - Safety: sender can retract a PENDING request by deleting instead of cancelling
      allow delete: if request.auth != null && (
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );
    }

    // ============================================
    // NEW: Friends Feature - Chat Messages
    // ============================================
    match /chats/{chatId}/messages/{messageId} {
      // Read if user is in the chatId (chatId format: "userId1_userId2")
      // This avoids extra document reads by parsing the chatId
      function isParticipantFromChatId() {
        let userIds = chatId.split('_');
        return request.auth.uid == userIds[0] || request.auth.uid == userIds[1];
      }

      // Read if participant in chat (determined from chatId)
      allow read: if request.auth != null && isParticipantFromChatId();

      // Create if participant and sender matches auth.uid
      allow create: if request.auth != null 
        && isParticipantFromChatId()
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.content.size() > 0
        && request.resource.data.content.size() <= 2000;

      // Update only allowed for marking as read
      allow update: if request.auth != null 
        && isParticipantFromChatId()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);

      // Allow participants to delete messages (cleanup when unfriending)
      allow delete: if request.auth != null && isParticipantFromChatId();
    }

    // ============================================
    // NEW: Friends Feature - Chat Metadata
    // ============================================
    match /chats/{chatId}/metadata/info {
      // Helper function to check if user is participant based on chatId format
      function isParticipantFromChatId() {
        // chatId format is "userId1_userId2" (sorted)
        let userIds = chatId.split('_');
        return request.auth.uid == userIds[0] || request.auth.uid == userIds[1];
      }

      // Allow read if user is participant
      allow read: if request.auth != null && (
        // Check existing participants list if document exists
        (resource != null && request.auth.uid in resource.data.participants) ||
        // Or infer from chatId pattern
        isParticipantFromChatId()
      );

      // Allow write if user is participant
      allow write: if request.auth != null && (
        // Check participants field in the data being written (if present)
        (request.resource.data.participants != null &&
         request.auth.uid in request.resource.data.participants) ||
        // Or infer from chatId pattern (for updates that don't include participants field)
        isParticipantFromChatId()
      );
    }

    // ============================================
    // DEFAULT: Deny all other access
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}